
grammar Redcode
  rule s_
    whitespace*
  end
  
  rule S_
    space+
  end

  rule space
    [ \t\r\n]
  end

  rule instruction
    # (label_list ' ')? operation ' ' (mode ' ')? expr ' '* {
    operation S_ operand s_ {
      def value
        {
          :operation => operation.value,
          :a         => operand.value
        }
      end
    }
    /
    operation S_ a:operand s_ "," s_ b:operand s_ {
      def value
        {
          :operation => operation.value,
          :a         => a.value,
          :b         => b.value
        }
      end
    }
  end
  
  rule operand
    mode? s_ expr {
      def value
        {
          :mode => mode.text_value,
          :operand => expr.value
        }
      end
    }
  end
  
  rule label
    [a-zA-Z] [a-zA-Z0-9]*
  end
  
  rule operation
    opcode {
      def value
        {:opcode => self.text_value}
      end
    }
    /
    opcode "." modifier {
      def value
        {
          :opcode => opcode.text_value,
          :modifier => modifier.text_value
        }
      end
    }
  end
  
  rule opcode
    "dat" / "mov" / "add" / "sub" / "mul" / "div" / "mod" /
    "jmp" / "jmz" / "jmn" / "djn" / "cmp" / "slt" / "spl" /
    "org" / "equ" / "end"
  end
  
  rule modifier
    "a" / "b" / "ab" / "ba" / "f" / "x" / "i"
  end
  
  rule mode
    "#" / "$" / "@" / "<" / ">"
  end
  
  rule primary
    label {
      def value
        label.to_s.to_sym
      end
    }
    /
    number
  end
  
  rule number
    ("+" / "-")? [0-9]+ {
      def value
        self.to_s.to_i
      end
    }
  end
end