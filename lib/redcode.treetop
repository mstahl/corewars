
grammar Redcode
  rule instruction
    # (label_list ' ')? operation ' ' (mode ' ')? expr ' '* {
    s_ operation S_ operand s_ {
      def value
        {
          :operation => operation.value,
          :a         => operand.value
        }
      end
    }
    /
    s_ operation S_ a:operand s_ "," s_ b:operand s_ {
      def value
        {
          :operation => operation.value,
          :a         => a.value,
          :b         => b.value
        }
      end
    }
  end
  
  rule operand
    primary
    /
    mode primary {
      def value
        {
          :mode => mode.text_value,
          :operand => primary.value
        }
      end
    }
  end
  
  rule label
    [a-zA-Z] [a-zA-Z0-9_]* {
      def value
        self.text_value.to_sym
      end
    }
  end
  
  rule operation
    opcode {
      def value
        {:opcode => self.text_value}
      end
    }
    /
    opcode "." modifier {
      def value
        {
          :opcode => opcode.text_value.to_sym,
          :modifier => modifier.text_value.to_sym
        }
      end
    }
  end
  
  rule opcode
    "dat" / "mov" / "add" / "sub" / "mul" / "div" / "mod" / "jmp" / "jmz" / "jmn" / "djn" / "cmp" / "slt" / "spl" / "org" / "equ" / "end"
  end
  
  rule modifier
    "a" / "b" / "ab" / "ba" / "f" / "x" / "i"
  end
  
  rule mode
    "#" / "$" / "@" / "<" / ">"
  end
  
  rule primary
    label
    /
    number
  end
  
  rule number
    # sign:("+" / "-") n:[0-9]+ {
    #   def value
    #     (if sign.text_value == "+" then 1 else -1 end) * n.text_value.to_i
    #   end
    #   
    # }
    # /
    [0-9]+ {
      def value
        self.text_value.to_i
      end
    }
  end
  
  rule s_
    space*
  end
  
  rule S_
    space+
  end

  rule space
    [ \t\r\n]
  end
end


