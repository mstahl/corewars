
grammar Redcode
  rule instruction
    lbl:( label s_ ":" )? s_ operation S_ a:operand s_ "," s_ b:operand {
      def value
        {
          :operation => operation.value,
          :a         => a.value,
          :b         => b.value,
          :labels    => if lbl.text_value.blank? then nil else lbl.text_value.gsub(/\s*:/, '').to_sym end
        }
      end
    }
    /
    lbl:( label s_ ":" )? s_ operation S_ operand {
      def value
        {
          :operation => operation.value,
          :a         => operand.value,
          :b         => nil,
          :labels    => if lbl.text_value.blank? then nil else lbl.text_value.gsub(/\s*:/, '').to_sym end
        }
      end
    }
  end
  
  rule operand
    primary
    /
    mode primary {
      def value
        {
          :mode => mode.text_value.to_s,
          :value => primary.text_value.to_i
        }
      end
    }
  end
  
  
  rule label
    [a-zA-Z] [a-zA-Z0-9_]* {
      def value
        self.text_value.to_sym
      end
    }
  end
  
  rule operation
    opcode m:( "." modifier )? {
      def value
        {
          :opcode => self.text_value.to_sym,
          :modifier => m.text_value.to_sym
        }
      end
    }
  end
  
  rule opcode
    "dat" / "mov" / "add" / "sub" / "mul" / "div" / "mod" / "jmp" / "jmz" / "jmn" / "djn" / "cmp" / "slt" / "spl" / "org" / "equ" / "end"
  end
  
  rule modifier
    "a" / "b" / "ab" / "ba" / "f" / "x" / "i"
  end
  
  rule mode
    "#" / "$" / "@" / "<" / ">"
  end
  
  rule primary
    label
    /
    number
  end
  
  rule number
    [0-9]+ {
      def value
        self.text_value.to_i
      end
    }
  end
  
  rule s_
    space*
  end
  
  rule S_
    space+
  end

  rule space
    [ \t\r\n]
  end
end


